<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->

<center>![](https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/icon/beer.png)</center>

>Objective-C 运行时是 OS X 和 iOS 执行 Objective-C 的一部分, 它还负责动态地追踪那些类存在, 这些类定义了那些方法, 以及查看消息是否恰当地在对象之间传递.

## 类:

OC 中一切都被设计成了对象, 一个类被初始化成一个实例, 这个实例是一个对象. 实际上一个**类本质上也是一个对象**, 在 Runtime 中用结构体表示.

* Runtime 的相关定义:

~~~~{c}
// 描述类中的一个方法
typedef struct objc_method *Method;

// 实例变量
typedef struct objc_ivar *Ivar;

// 类别Category
typedef struct objc_category *Category;

// 类中声明的属性
typedef struct objc_property *objc_property_t;
~~~~

* 类在 Runtime 中的表示:

~~~~{c}
// 类在 Runtime 中的表示
struct objc_class {
    Class isa; // 指针，顾名思义，表示是一个什么，
    // 实例的isa指向类对象，类对象的isa指向元类

#if !__OBJC2__
    Class super_class;  // 指向父类
    const char *name;  // 类名
    long version;
    long info;
    long instance_size
    struct objc_ivar_list *ivars // 成员变量列表
    struct objc_method_list **methodLists; // 方法列表
    struct objc_cache *cache; // 缓存
    // 一种优化，调用过的方法存入缓存列表，下次调用先找缓存
    struct objc_protocol_list *protocols // 协议列表
    #endif
} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */
~~~~

## 内省:

内省 (Introspection) 是 OC 运行时的一个特性: 它能够在对象运行的时候自动回答关于自身的问题.

* 获取列表: 通过 Runtime 的一系列方法获取类的一些信息 , 包括属性列表, 方法列表, 成员变量列表, 和遵循的协议列表.

~~~~{c}
unsigned int count;
    // 获取属性列表
    objc_property_t *propertyList = class_copyPropertyList([self class], &count);
    for (unsigned int i=0; i<count; i++) {
        const char *propertyName = property_getName(propertyList[i]);
        NSLog(@"property---->%@", [NSString stringWithUTF8String:propertyName]);
    }

    // 获取方法列表
    Method *methodList = class_copyMethodList([self class], &count);
    for (unsigned int i; i<count; i++) {
        Method method = methodList[i];
        NSLog(@"method---->%@", NSStringFromSelector(method_getName(method)));
    }

    // 获取成员变量列表
    Ivar *ivarList = class_copyIvarList([self class], &count);
    for (unsigned int i; i<count; i++) {
        Ivar myIvar = ivarList[i];
        const char *ivarName = ivar_getName(myIvar);
        NSLog(@"Ivar---->%@", [NSString stringWithUTF8String:ivarName]);
    }

    // 获取协议列表
    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);
    for (unsigned int i; i<count; i++) {
        Protocol *myProtocal = protocolList[i];
        const char *protocolName = protocol_getName(myProtocal);
        NSLog(@"protocol---->%@", [NSString stringWithUTF8String:protocolName]);
    }
~~~~

## 方法调用:

* 在 Runtime 中方法的调用过程: **如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。
如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作**. 

 1. 首先, 在相应操作的对象中的缓存方法列表中找调用的方法, 如果找到, 转向相应实现并执行.
 2. 如果没找到, 在相应操作的对象中的方法列表中找调用的方法, 如果找到, 转向相应实现执行.
 3. 如果没找到, 去父类指针所指向的对象中执行1, 2.
 4. 以此类推, 如果一直到根类还没找到, 转向拦截调用.
 5.  如果没有重写拦截调用的方法, 程序报错.

* 启发：
 * 重写父类的方法, 并没有覆盖掉父类的方法, 只是在当前类对象中找到了这个方法后就不会再去父类中找了.
 *  如果想调用已经重写过的方法的父类的实现, 只需使用 `super` 这个编译器标识, 它会在运行时跳过在当前的类对象中寻找方法的过程.

## 方法拦截调用:

在方法调用中说到了, 如果没有找到方法就会转向拦截调用.
那么什么是拦截调用呢. 
拦截调用就是，在找不到调用的方法程序崩溃之前, 你有机会通过重写 NSObject 的四个方法来处理.

~~~~{c}
+ (BOOL)resolveClassMethod:(SEL)sel;
+ (BOOL)resolveInstanceMethod:(SEL)sel;
// 后两个方法需要转发到其他的类处理
- (id)forwardingTargetForSelector:(SEL)aSelector;
- (void)forwardInvocation:(NSInvocation *)anInvocation;
~~~~

 第一个方法是当你调用一个不存在的类方法的时候, 会调用这个方法，默认返回NO, 你可以加上自己的处理然后返回YES. 第二个方法和第一个方法相似, 只不过处理的是实例方法.

 第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类, 只需要你返回一个有这个方法的target.

 第四个方法是将你调用的不存在的方法打包成 NSInvocation 传给你。做完你自己的处理后, 调用 `invokeWithTarget:` 方法让某个 target 触发这个方法.

## 动态添加方法:

重写了拦截调用的方法并且返回了 YES, 我们要怎么处理呢?
有一个办法是根据传进来的 SEL 类型的 selector 动态添加一个方法.

首先从外部隐式调用一个不存在的方法:

~~~~{c}
//隐式调用方法
[target performSelector:@selector(resolveAdd:) withObject:@"test"];
~~~~

然后，在target对象内部重写拦截调用的方法，动态添加方法。

~~~~{c}
void runAddMethod(id self, SEL _cmd, NSString *string){
    NSLog(@"add C IMP ", string);
}
+ (BOOL)resolveInstanceMethod:(SEL)sel{

    // 给本类动态添加一个方法
    if ([NSStringFromSelector(sel) isEqualToString:@"resolveAdd:"]) {
        class_addMethod(self, sel, (IMP)runAddMethod, "v@:*");
    }
    return YES;
}
~~~~

其中 `class_addMethod` 的四个参数分别是：

1. Class cls 给哪个类添加方法, 本例中是 self
2. SEL name 添加的方法, 本例中是重写的拦截调用传进来的 selector
3. IMP imp 方法的实现, C 方法的方法实现可以直接获得. 如果是 OC 方法, 可以用 `+ (IMP)instanceMethodForSelector:(SEL)aSelector;` 获得方法的实现.
4. `"v@:*"`方法的签名, 代表有一个参数的方法.


## 方法交换:

方法交换, 顾名思义，就是将两个方法的实现交换. 例如: 将 A 方法和 B 方法交换, 调用 A 方法的时候, 就会执行 B 方法中的代码, 反之亦然. 
这是参考 Mattt 大神在 NSHipster 上的文章自己写的代码.

~~~~{c}
#import "UIViewController+swizzling.h"
#import <objc/runtime.h>

@implementation UIViewController (swizzling)

// load方法会在类第一次加载的时候被调用
// 调用的时间比较靠前，适合在这个方法里做方法交换
+ (void)load{
    // 方法交换应该被保证，在程序中只会执行一次
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{

        // 获得viewController的生命周期方法的selector
        SEL systemSel = @selector(viewWillAppear:);
        // 自己实现的将要被交换的方法的selector
        SEL swizzSel = @selector(swiz_viewWillAppear:);
        // 两个方法的Method
        Method systemMethod = class_getInstanceMethod([self class], systemSel);
        Method swizzMethod = class_getInstanceMethod([self class], swizzSel);

        // 首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
        BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(swizzMethod), method_getTypeEncoding(swizzMethod));
        if (isAdd) {
            // 如果成功，说明类中不存在这个方法的实现
            // 将被交换方法的实现替换到这个并不存在的实现
            class_replaceMethod(self, swizzSel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod));
        }else{
            // 否则，交换两个方法的实现
            method_exchangeImplementations(systemMethod, swizzMethod);
        }

    });
}

- (void)swiz_viewWillAppear:(BOOL)animated{
    // 这时候调用自己，看起来像是死循环
    // 但是其实自己的实现已经被替换了
    [self swiz_viewWillAppear:animated];
    NSLog(@"swizzle");
}

@end
~~~~

在一个自己定义的viewController中重写viewWillAppear

~~~~{c}
- (void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];
    NSLog(@"viewWillAppear");
}
~~~~

## 关联对象:

现在你准备用一个系统的类, 但是系统的类并不能满足你的需求, 你需要额外添加一个属性.
这种情况的一般解决办法就是继承,
但是, 只增加一个属性, 就去继承一个类, 总是觉得太麻烦类.
这个时候, 可以使用 Runtime 关联属性.

~~~~{c}
// 首先定义一个全局变量，用它的地址作为关联对象的key
static char associatedObjectKey;
// 设置关联对象
objc_setAssociatedObject(target, &associatedObjectKey, @"添加的字符串属性", OBJC_ASSOCIATION_RETAIN_NONATOMIC); // 获取关联对象
NSString *string = objc_getAssociatedObject(target, &associatedObjectKey);
NSLog(@"AssociatedObject = %@", string);
~~~~

`objc_setAssociatedObject` 的四个参数:

* `id object` 给谁设置关联对象.
*  `const void *key` 关联对象唯一的key, 获取时会用到.
* `id value` 关联对象。
* `objc_AssociationPolicy` 关联策略, 有以下几种策略:

~~~~{c}
enum {
    OBJC_ASSOCIATION_ASSIGN = 0,
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, 
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
    OBJC_ASSOCIATION_RETAIN = 01401,
    OBJC_ASSOCIATION_COPY = 01403 
};
~~~~

* `objc_getAssociatedObject` 的两个参数.

* `id object` 获取谁的关联对象.
* `const void *key` 根据这个唯一的 key 获取关联对象。

你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中, 方便使用:

~~~~{c}
// 添加关联对象
- (void)addAssociatedObject:(id)object{
    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
// 获取关联对象
- (id)getAssociatedObject{
    return objc_getAssociatedObject(self, _cmd);
}
~~~~

**注意: 这里面我们把 `getAssociatedObject` 方法的地址作为唯一的key, `_cmd` 代表当前调用方法的地址.**

___
> 英国著名科幻作家: 阿瑟 . 克拉克: " 任何足够先进的技术都与魔法无异. "  

>古往今来的所有程序员: "魔法是愚蠢的."

* 方法交换对于我来说更像是实现一种思想的最佳技术: AOP面向切面编程. 既然是切面, 就一定不要忘记, 交换完再调回自己.
* 一定要保证只交换一次, 否则就会很乱.
* Runtime 技术很危险, 谨慎使用.

祝编码愉快~

<center>![](https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/emojis/beers.png)</center>

参考: 

* [iOS~runtime理解](http://www.jianshu.com/p/927c8384855a)
* Objective-C 编程 (第二版) 附录
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p></p><center><img src="https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/icon/beer.png" alt="" title=""></center><p></p>

<blockquote>
  <p>Objective-C 运行时是 OS X 和 iOS 执行 Objective-C 的一部分, 它还负责动态地追踪那些类存在, 这些类定义了那些方法, 以及查看消息是否恰当地在对象之间传递.</p>
</blockquote>

<h2 id="">类:</h2>

<p>OC 中一切都被设计成了对象, 一个类被初始化成一个实例, 这个实例是一个对象. 实际上一个<strong>类本质上也是一个对象</strong>, 在 Runtime 中用结构体表示.</p>

<ul>
<li>Runtime 的相关定义:</li>
</ul>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">// 描述类中的一个方法
</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_method <span class="token operator">*</span>Method<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 实例变量
</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_ivar <span class="token operator">*</span>Ivar<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 类别Category
</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_category <span class="token operator">*</span>Category<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 类中声明的属性
</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> objc_property <span class="token operator">*</span>objc_property_t<span class="token punctuation">;</span>
</code></pre>

<ul>
<li>类在 Runtime 中的表示:</li>
</ul>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">// 类在 Runtime 中的表示
</span><span class="token keyword">struct</span> objc_class <span class="token punctuation">{</span>
    Class <span class="token class-name">isa</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 指针，顾名思义，表示是一个什么，
</span>   <span class="token comment" spellcheck="true"> // 实例的isa指向类对象，类对象的isa指向元类
</span>
<span class="token property">#if !__OBJC2__</span>
    Class <span class="token class-name">super_class</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"> // 指向父类
</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"> // 类名
</span>    <span class="token keyword">long</span> version<span class="token punctuation">;</span>
    <span class="token keyword">long</span> info<span class="token punctuation">;</span>
    <span class="token keyword">long</span> instance_size
    <span class="token keyword">struct</span> objc_ivar_list <span class="token operator">*</span>ivars<span class="token comment" spellcheck="true"> // 成员变量列表
</span>    <span class="token keyword">struct</span> objc_method_list <span class="token operator">*</span><span class="token operator">*</span>methodLists<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 方法列表
</span>    <span class="token keyword">struct</span> objc_cache <span class="token operator">*</span>cache<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 缓存
</span>   <span class="token comment" spellcheck="true"> // 一种优化，调用过的方法存入缓存列表，下次调用先找缓存
</span>    <span class="token keyword">struct</span> objc_protocol_list <span class="token operator">*</span>protocols<span class="token comment" spellcheck="true"> // 协议列表
</span>    #endif
<span class="token punctuation">}</span> OBJC2_UNAVAILABLE<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/* Use `Class` instead of `struct objc_class *` */</span>
</code></pre>

<h2 id="">内省:</h2>

<p>内省 (Introspection) 是 OC 运行时的一个特性: 它能够在对象运行的时候自动回答关于自身的问题.</p>

<ul>
<li>获取列表: 通过 Runtime 的一系列方法获取类的一些信息 , 包括属性列表, 方法列表, 成员变量列表, 和遵循的协议列表.</li>
</ul>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true"> // 获取属性列表
</span>    objc_property_t <span class="token operator">*</span>propertyList <span class="token operator">=</span> <span class="token function">class_copyPropertyList<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>propertyName <span class="token operator">=</span> <span class="token function">property_getName<span class="token punctuation">(</span></span>propertyList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"property----&gt;%@"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSString stringWithUTF8String<span class="token punctuation">:</span>propertyName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true"> // 获取方法列表
</span>    Method <span class="token operator">*</span>methodList <span class="token operator">=</span> <span class="token function">class_copyMethodList<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Method method <span class="token operator">=</span> methodList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"method----&gt;%@"</span><span class="token punctuation">,</span> <span class="token function">NSStringFromSelector<span class="token punctuation">(</span></span><span class="token function">method_getName<span class="token punctuation">(</span></span>method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true"> // 获取成员变量列表
</span>    Ivar <span class="token operator">*</span>ivarList <span class="token operator">=</span> <span class="token function">class_copyIvarList<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Ivar myIvar <span class="token operator">=</span> ivarList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ivarName <span class="token operator">=</span> <span class="token function">ivar_getName<span class="token punctuation">(</span></span>myIvar<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"Ivar----&gt;%@"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSString stringWithUTF8String<span class="token punctuation">:</span>ivarName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true"> // 获取协议列表
</span>    __unsafe_unretained Protocol <span class="token operator">*</span><span class="token operator">*</span>protocolList <span class="token operator">=</span> <span class="token function">class_copyProtocolList<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Protocol <span class="token operator">*</span>myProtocal <span class="token operator">=</span> protocolList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>protocolName <span class="token operator">=</span> <span class="token function">protocol_getName<span class="token punctuation">(</span></span>myProtocal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"protocol----&gt;%@"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSString stringWithUTF8String<span class="token punctuation">:</span>protocolName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>

<h2 id="">方法调用:</h2>

<ul>
<li><p>在 Runtime 中方法的调用过程: <strong>如果用实例对象调用实例方法，会到实例的isa指针指向的对象（也就是类对象）操作。
如果调用的是类方法，就会到类对象的isa指针指向的对象（也就是元类对象）中操作</strong>. </p>

<ol><li>首先, 在相应操作的对象中的缓存方法列表中找调用的方法, 如果找到, 转向相应实现并执行.</li>
<li>如果没找到, 在相应操作的对象中的方法列表中找调用的方法, 如果找到, 转向相应实现执行.</li>
<li>如果没找到, 去父类指针所指向的对象中执行1, 2.</li>
<li>以此类推, 如果一直到根类还没找到, 转向拦截调用.</li>
<li>如果没有重写拦截调用的方法, 程序报错.</li></ol></li>
<li><p>启发：</p>

<ul><li>重写父类的方法, 并没有覆盖掉父类的方法, 只是在当前类对象中找到了这个方法后就不会再去父类中找了.</li>
<li>如果想调用已经重写过的方法的父类的实现, 只需使用 <code>super</code> 这个编译器标识, 它会在运行时跳过在当前的类对象中寻找方法的过程.</li></ul></li>
</ul>

<h2 id="">方法拦截调用:</h2>

<p>在方法调用中说到了, 如果没有找到方法就会转向拦截调用.
那么什么是拦截调用呢. 
拦截调用就是，在找不到调用的方法程序崩溃之前, 你有机会通过重写 NSObject 的四个方法来处理.</p>

<pre class=" language-c"><code class=" language-c"><span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>resolveClassMethod<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel<span class="token punctuation">;</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>resolveInstanceMethod<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 后两个方法需要转发到其他的类处理
</span><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>forwardingTargetForSelector<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>aSelector<span class="token punctuation">;</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>forwardInvocation<span class="token punctuation">:</span><span class="token punctuation">(</span>NSInvocation <span class="token operator">*</span><span class="token punctuation">)</span>anInvocation<span class="token punctuation">;</span>
</code></pre>

<p>第一个方法是当你调用一个不存在的类方法的时候, 会调用这个方法，默认返回NO, 你可以加上自己的处理然后返回YES. 第二个方法和第一个方法相似, 只不过处理的是实例方法.</p>

<p>第三个方法是将你调用的不存在的方法重定向到一个其他声明了这个方法的类, 只需要你返回一个有这个方法的target.</p>

<p>第四个方法是将你调用的不存在的方法打包成 NSInvocation 传给你。做完你自己的处理后, 调用 <code>invokeWithTarget:</code> 方法让某个 target 触发这个方法.</p>

<h2 id="">动态添加方法:</h2>

<p>重写了拦截调用的方法并且返回了 YES, 我们要怎么处理呢?
有一个办法是根据传进来的 SEL 类型的 selector 动态添加一个方法.</p>

<p>首先从外部隐式调用一个不存在的方法:</p>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">//隐式调用方法
</span><span class="token punctuation">[</span>target performSelector<span class="token punctuation">:</span>@<span class="token function">selector<span class="token punctuation">(</span></span>resolveAdd<span class="token punctuation">:</span><span class="token punctuation">)</span> withObject<span class="token punctuation">:</span>@<span class="token string">"test"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>

<p>然后，在target对象内部重写拦截调用的方法，动态添加方法。</p>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">void</span> <span class="token function">runAddMethod<span class="token punctuation">(</span></span>id self<span class="token punctuation">,</span> SEL _cmd<span class="token punctuation">,</span> NSString <span class="token operator">*</span>string<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"add C IMP "</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">+</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>resolveInstanceMethod<span class="token punctuation">:</span><span class="token punctuation">(</span>SEL<span class="token punctuation">)</span>sel<span class="token punctuation">{</span>

   <span class="token comment" spellcheck="true"> // 给本类动态添加一个方法
</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">NSStringFromSelector<span class="token punctuation">(</span></span>sel<span class="token punctuation">)</span> isEqualToString<span class="token punctuation">:</span>@<span class="token string">"resolveAdd:"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">class_addMethod<span class="token punctuation">(</span></span>self<span class="token punctuation">,</span> sel<span class="token punctuation">,</span> <span class="token punctuation">(</span>IMP<span class="token punctuation">)</span>runAddMethod<span class="token punctuation">,</span> <span class="token string">"v@:*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> YES<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>其中 <code>class_addMethod</code> 的四个参数分别是：</p>

<ol>
<li>Class cls 给哪个类添加方法, 本例中是 self</li>
<li>SEL name 添加的方法, 本例中是重写的拦截调用传进来的 selector</li>
<li>IMP imp 方法的实现, C 方法的方法实现可以直接获得. 如果是 OC 方法, 可以用 <code>+ (IMP)instanceMethodForSelector:(SEL)aSelector;</code> 获得方法的实现.</li>
<li><code>"v@:*"</code>方法的签名, 代表有一个参数的方法.</li>
</ol>

<h2 id="">方法交换:</h2>

<p>方法交换, 顾名思义，就是将两个方法的实现交换. 例如: 将 A 方法和 B 方法交换, 调用 A 方法的时候, 就会执行 B 方法中的代码, 反之亦然. 
这是参考 Mattt 大神在 NSHipster 上的文章自己写的代码.</p>

<pre class=" language-c"><code class=" language-c"><span class="token property">#import </span><span class="token string">"UIViewController+swizzling.h"</span>
<span class="token property">#import &lt;objc/runtime.h&gt;</span>

@implementation UIViewController <span class="token punctuation">(</span>swizzling<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">
// load方法会在类第一次加载的时候被调用
</span><span class="token comment" spellcheck="true">// 调用的时间比较靠前，适合在这个方法里做方法交换
</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>load<span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // 方法交换应该被保证，在程序中只会执行一次
</span>    <span class="token keyword">static</span> dispatch_once_t onceToken<span class="token punctuation">;</span>
    <span class="token function">dispatch_once<span class="token punctuation">(</span></span><span class="token operator">&amp;</span>onceToken<span class="token punctuation">,</span> <span class="token operator">^</span><span class="token punctuation">{</span>

       <span class="token comment" spellcheck="true"> // 获得viewController的生命周期方法的selector
</span>        SEL systemSel <span class="token operator">=</span> @<span class="token function">selector<span class="token punctuation">(</span></span>viewWillAppear<span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true"> // 自己实现的将要被交换的方法的selector
</span>        SEL swizzSel <span class="token operator">=</span> @<span class="token function">selector<span class="token punctuation">(</span></span>swiz_viewWillAppear<span class="token punctuation">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true"> // 两个方法的Method
</span>        Method systemMethod <span class="token operator">=</span> <span class="token function">class_getInstanceMethod<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> systemSel<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Method swizzMethod <span class="token operator">=</span> <span class="token function">class_getInstanceMethod<span class="token punctuation">(</span></span><span class="token punctuation">[</span>self class<span class="token punctuation">]</span><span class="token punctuation">,</span> swizzSel<span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment" spellcheck="true"> // 首先动态添加方法，实现是被交换的方法，返回值表示添加成功还是失败
</span>        BOOL isAdd <span class="token operator">=</span> <span class="token function">class_addMethod<span class="token punctuation">(</span></span>self<span class="token punctuation">,</span> systemSel<span class="token punctuation">,</span> <span class="token function">method_getImplementation<span class="token punctuation">(</span></span>swizzMethod<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">method_getTypeEncoding<span class="token punctuation">(</span></span>swizzMethod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isAdd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment" spellcheck="true"> // 如果成功，说明类中不存在这个方法的实现
</span>           <span class="token comment" spellcheck="true"> // 将被交换方法的实现替换到这个并不存在的实现
</span>            <span class="token function">class_replaceMethod<span class="token punctuation">(</span></span>self<span class="token punctuation">,</span> swizzSel<span class="token punctuation">,</span> <span class="token function">method_getImplementation<span class="token punctuation">(</span></span>systemMethod<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">method_getTypeEncoding<span class="token punctuation">(</span></span>systemMethod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
           <span class="token comment" spellcheck="true"> // 否则，交换两个方法的实现
</span>            <span class="token function">method_exchangeImplementations<span class="token punctuation">(</span></span>systemMethod<span class="token punctuation">,</span> swizzMethod<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>swiz_viewWillAppear<span class="token punctuation">:</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>animated<span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // 这时候调用自己，看起来像是死循环
</span>   <span class="token comment" spellcheck="true"> // 但是其实自己的实现已经被替换了
</span>    <span class="token punctuation">[</span>self swiz_viewWillAppear<span class="token punctuation">:</span>animated<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"swizzle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

@end
</code></pre>

<p>在一个自己定义的viewController中重写viewWillAppear</p>

<pre class=" language-c"><code class=" language-c"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>viewWillAppear<span class="token punctuation">:</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>animated<span class="token punctuation">{</span>
    <span class="token punctuation">[</span>super viewWillAppear<span class="token punctuation">:</span>animated<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"viewWillAppear"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<h2 id="">关联对象:</h2>

<p>现在你准备用一个系统的类, 但是系统的类并不能满足你的需求, 你需要额外添加一个属性.
这种情况的一般解决办法就是继承,
但是, 只增加一个属性, 就去继承一个类, 总是觉得太麻烦类.
这个时候, 可以使用 Runtime 关联属性.</p>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">// 首先定义一个全局变量，用它的地址作为关联对象的key
</span><span class="token keyword">static</span> <span class="token keyword">char</span> associatedObjectKey<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 设置关联对象
</span><span class="token function">objc_setAssociatedObject<span class="token punctuation">(</span></span>target<span class="token punctuation">,</span> <span class="token operator">&amp;</span>associatedObjectKey<span class="token punctuation">,</span> @<span class="token string">"添加的字符串属性"</span><span class="token punctuation">,</span> OBJC_ASSOCIATION_RETAIN_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 获取关联对象
</span>NSString <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token function">objc_getAssociatedObject<span class="token punctuation">(</span></span>target<span class="token punctuation">,</span> <span class="token operator">&amp;</span>associatedObjectKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">NSLog<span class="token punctuation">(</span></span>@<span class="token string">"AssociatedObject = %@"</span><span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>

<p><code>objc_setAssociatedObject</code> 的四个参数:</p>

<ul>
<li><code>id object</code> 给谁设置关联对象.</li>
<li><code>const void *key</code> 关联对象唯一的key, 获取时会用到.</li>
<li><code>id value</code> 关联对象。</li>
<li><code>objc_AssociationPolicy</code> 关联策略, 有以下几种策略:</li>
</ul>

<pre class=" language-c"><code class=" language-c"><span class="token keyword">enum</span> <span class="token punctuation">{</span>
    OBJC_ASSOCIATION_ASSIGN <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    OBJC_ASSOCIATION_RETAIN_NONATOMIC <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 
    OBJC_ASSOCIATION_COPY_NONATOMIC <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    OBJC_ASSOCIATION_RETAIN <span class="token operator">=</span> <span class="token number">01401</span><span class="token punctuation">,</span>
    OBJC_ASSOCIATION_COPY <span class="token operator">=</span> <span class="token number">01403</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>

<ul>
<li><p><code>objc_getAssociatedObject</code> 的两个参数.</p></li>
<li><p><code>id object</code> 获取谁的关联对象.</p></li>
<li><code>const void *key</code> 根据这个唯一的 key 获取关联对象。</li>
</ul>

<p>你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中, 方便使用:</p>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">// 添加关联对象
</span><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>addAssociatedObject<span class="token punctuation">:</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>object<span class="token punctuation">{</span>
    <span class="token function">objc_setAssociatedObject<span class="token punctuation">(</span></span>self<span class="token punctuation">,</span> @<span class="token function">selector<span class="token punctuation">(</span></span>getAssociatedObject<span class="token punctuation">)</span><span class="token punctuation">,</span> object<span class="token punctuation">,</span> OBJC_ASSOCIATION_RETAIN_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">
// 获取关联对象
</span><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span>getAssociatedObject<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">objc_getAssociatedObject<span class="token punctuation">(</span></span>self<span class="token punctuation">,</span> _cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p><strong>注意: 这里面我们把 <code>getAssociatedObject</code> 方法的地址作为唯一的key, <code>_cmd</code> 代表当前调用方法的地址.</strong></p>

<hr>

<blockquote>
  <p>英国著名科幻作家: 阿瑟 . 克拉克: " 任何足够先进的技术都与魔法无异. "  </p>
  
  <p>古往今来的所有程序员: "魔法是愚蠢的."</p>
</blockquote>

<ul>
<li>方法交换对于我来说更像是实现一种思想的最佳技术: AOP面向切面编程. 既然是切面, 就一定不要忘记, 交换完再调回自己.</li>
<li>一定要保证只交换一次, 否则就会很乱.</li>
<li>Runtime 技术很危险, 谨慎使用.</li>
</ul>

<p>祝编码愉快~</p>

<p></p><center><img src="https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/emojis/beers.png" alt="" title=""></center><p></p>

<p>参考: </p>

<ul>
<li><a href="http://www.jianshu.com/p/927c8384855a">iOS~runtime理解</a></li>
<li>Objective-C 编程 (第二版) 附录</li>
</ul>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "oc_runtime.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
