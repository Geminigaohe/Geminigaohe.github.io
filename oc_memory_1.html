<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
## 前言 

自从接触 OC, 从来没有研究过它的内存管理方案, 只是使用. 自学 iOS 开发的时候正值 ARC 盛行, 在对象内部声明对象属性也仅仅是添加 `strong` 关键字, 对, 不管一切对象属性都是 `@property (strong, nonatomic) Objc *obj;` 这样. 后果不言而喻, 造成很多内存的问题.

通过阅读书籍 (英文不好, 无法看文档是一个坑 =_=|||), 想积累一些关于 OC 内存管理的知识, 会写若干篇的文章用来填坑 ...... 下面是参考的书籍:

* Objective-C 基础教程 (第二版)
* Objective-C 编程 (第二版)
* Objective-C 高级编程 iOS 与 OS X 多线程和内存管理
* iOS 编程 (第四版)
* Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法

___

## OC 中什么是内存管理, 为什么要内存管理 ?

*对象*是面向对象编程中的*主体*, 对象可以是逻辑上的事物, 也可以是真实世界中的事物. OC 在创建**堆**中创建对象, 并用一个指针指向这个对象的内存地址.(稍后讨论一下栈和堆), 栈中的内存系统可以自动回收管理, 但是堆中的内存程序却无法真正意义上进行回收, 必须通过我们手动才能将其回收交给内存. 程序占用的堆大小是有限的, 如果长时间不回收堆中的内存, 就会造成**内存泄漏**, 所以:

* *OC 的内存管理* 就是管理堆中的内存.
* 如果不进行内存管理, 就会造成程序崩溃.

## 内存结构

一个由 C/C++ 编译的程序占用的内存分为以下几个部分:

![](https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/image/%E5%A0%86%E5%92%8C%E6%A0%88.jpg)

1. 栈区 (stack): 由编译器自动分配释放, 存放函数的参数值, 局部变量的值等. 其操作方式类似于数据结构中的栈.
2. 堆区 (heap): 一般由程序员分配释放,  若程序员不释放, 程序结束时可能由系统回收. 注意它与数据结构中的堆是两回事, 分配方与链表类似.
3. 全局区 (静态区) (static) : 全局变量和静态变量的存储是放在一块的, 初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.  在程序结束后由系统释放
4. 文字常量区: 常量字符串就是放在这里的. 程序结束后由系统释放.
5. 程序代码区: 存放函数体的二进制代码.

[iOS 关于堆和栈](https://geminigaohe.github.io/ios_stackandheap.html)

## 帧, 栈和堆

帧: "当程序执行某个方法 (或函数) 时, 会从内存中名为栈 (stack) 的区域分配一块内存空间, 这块内存空间称为帧 (frame). 帧负责保存程序在方法内声明的变量的值. 在方法内声明的变量称为局部变量 (local variable)."

栈: "当某个应用启动并运行 main 函数时, 它的帧会被保存在栈的底部. 当 main 调用另一个 方法 (或函数) 时, 这个方法 (或函数) 的帧会压入栈的顶部. 被调用的方法还可以再调用其 他方法, 依此类推, 最终会在栈中形成一个塔状的帧序列. 当被调用的方法 (或函数) 结束时, 程序会将其帧从栈顶 "弹出" 并释放. 如果同一个方法再次被调用, 则应用会创建一个全新的帧, 并将其压入栈的顶部."

堆 (heap): 是指内存中的另一块区域, 和栈是分开的, 为这两类内存区域分别取名堆和栈, 是为了能够形象地描述这两个概念. **栈会按后进先出的规则保存一组帧**, 而堆则包含了大量无序的活动对象, 需要通过指针来保存这些对象在堆中的地址.

iOS 应用在启动和运行时会持续创建需要的对象, 如果堆的空间是无限的, 则可以随意创 建所需的对象, 并且在应用运行期间不用释放. 
但是可供应用支配的堆空间是有限的, 而且 iOS 设备的内存也非常有限. 因此,当应用不再需要某些对象时, 就要将其释放掉. 这是非常重要的一步, 因为释放对象后, 可以将其占用的内存归还给堆, 使之能够被重新使用. 另外, **也要绝对避免释放应用正在使用的对象.**


##总结:

"栈是有序的帧构成的, 函数的帧在函数结束后会自动释放, 而堆里的对象却不会释放."
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">前言</h2>

<p>自从接触 OC, 从来没有研究过它的内存管理方案, 只是使用. 自学 iOS 开发的时候正值 ARC 盛行, 在对象内部声明对象属性也仅仅是添加 <code>strong</code> 关键字, 对, 不管一切对象属性都是 <code>@property (strong, nonatomic) Objc *obj;</code> 这样. 后果不言而喻, 造成很多内存的问题.</p>

<p>通过阅读书籍 (英文不好, 无法看文档是一个坑 =_=|||), 想积累一些关于 OC 内存管理的知识, 会写若干篇的文章用来填坑 ...... 下面是参考的书籍:</p>

<ul>
<li>Objective-C 基础教程 (第二版)</li>
<li>Objective-C 编程 (第二版)</li>
<li>Objective-C 高级编程 iOS 与 OS X 多线程和内存管理</li>
<li>iOS 编程 (第四版)</li>
<li>Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法</li>
</ul>

<hr>

<h2 id="oc">OC 中什么是内存管理, 为什么要内存管理 ?</h2>

<p><em>对象</em>是面向对象编程中的<em>主体</em>, 对象可以是逻辑上的事物, 也可以是真实世界中的事物. OC 在创建<strong>堆</strong>中创建对象, 并用一个指针指向这个对象的内存地址.(稍后讨论一下栈和堆), 栈中的内存系统可以自动回收管理, 但是堆中的内存程序却无法真正意义上进行回收, 必须通过我们手动才能将其回收交给内存. 程序占用的堆大小是有限的, 如果长时间不回收堆中的内存, 就会造成<strong>内存泄漏</strong>, 所以:</p>

<ul>
<li><em>OC 的内存管理</em> 就是管理堆中的内存.</li>
<li>如果不进行内存管理, 就会造成程序崩溃.</li>
</ul>

<h2 id="">内存结构</h2>

<p>一个由 C/C++ 编译的程序占用的内存分为以下几个部分:</p>

<p><img src="https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/image/%E5%A0%86%E5%92%8C%E6%A0%88.jpg" alt="" title=""></p>

<ol>
<li>栈区 (stack): 由编译器自动分配释放, 存放函数的参数值, 局部变量的值等. 其操作方式类似于数据结构中的栈.</li>
<li>堆区 (heap): 一般由程序员分配释放,  若程序员不释放, 程序结束时可能由系统回收. 注意它与数据结构中的堆是两回事, 分配方与链表类似.</li>
<li>全局区 (静态区) (static) : 全局变量和静态变量的存储是放在一块的, 初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域.  在程序结束后由系统释放</li>
<li>文字常量区: 常量字符串就是放在这里的. 程序结束后由系统释放.</li>
<li>程序代码区: 存放函数体的二进制代码.</li>
</ol>

<p><a href="https://geminigaohe.github.io/ios_stackandheap.html">iOS 关于堆和栈</a></p>

<h2 id="">帧, 栈和堆</h2>

<p>帧: "当程序执行某个方法 (或函数) 时, 会从内存中名为栈 (stack) 的区域分配一块内存空间, 这块内存空间称为帧 (frame). 帧负责保存程序在方法内声明的变量的值. 在方法内声明的变量称为局部变量 (local variable)."</p>

<p>栈: "当某个应用启动并运行 main 函数时, 它的帧会被保存在栈的底部. 当 main 调用另一个 方法 (或函数) 时, 这个方法 (或函数) 的帧会压入栈的顶部. 被调用的方法还可以再调用其 他方法, 依此类推, 最终会在栈中形成一个塔状的帧序列. 当被调用的方法 (或函数) 结束时, 程序会将其帧从栈顶 "弹出" 并释放. 如果同一个方法再次被调用, 则应用会创建一个全新的帧, 并将其压入栈的顶部."</p>

<p>堆 (heap): 是指内存中的另一块区域, 和栈是分开的, 为这两类内存区域分别取名堆和栈, 是为了能够形象地描述这两个概念. <strong>栈会按后进先出的规则保存一组帧</strong>, 而堆则包含了大量无序的活动对象, 需要通过指针来保存这些对象在堆中的地址.</p>

<p>iOS 应用在启动和运行时会持续创建需要的对象, 如果堆的空间是无限的, 则可以随意创 建所需的对象, 并且在应用运行期间不用释放. 
但是可供应用支配的堆空间是有限的, 而且 iOS 设备的内存也非常有限. 因此,当应用不再需要某些对象时, 就要将其释放掉. 这是非常重要的一步, 因为释放对象后, 可以将其占用的内存归还给堆, 使之能够被重新使用. 另外, <strong>也要绝对避免释放应用正在使用的对象.</strong></p>

<h2 id="">总结:</h2>

<p>"栈是有序的帧构成的, 函数的帧在函数结束后会自动释放, 而堆里的对象却不会释放."</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "oc_memory_1.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
