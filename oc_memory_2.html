<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
## 指针:

指针是一种数据类型, 它存储一个变量的内存地址. "因为对象只能通过指针访问, 所以人们常用指向对象的指针来称呼对象. **注意: 指针和它指向的对象是不同的.**"

## 引用计数:

"Cocoa 采用了一种叫做引用计数 (reference counting) 的技术, 有时也叫做保留计数 (retain counting). 每一个对象都有一个与之相关的整数, 被称作它的引用计数器或保留计数器."

"Objective-C 语言使用引用计数来管理内存, 也就是说每个对象有一个可以递增递减的计数器. 如果想让某个对象继续存活, 就将递增其引用计数器, 用完了之后就递减其计数. 计数器为0就表示没人关注此对象了, 于是就可以把它销毁."

在我看来, 引用计数器的值就等同于指向对象的指针的数量.

## 内存管理的思考方式:

手动内存管理 (manual reference counting) 很容易受到引用计数器的值得影响, 仅仅是将它递增递减, 实际上合理的思考方式应该是:

* 自己生成的对象, 自己持有.
* 非自己生成的对象, 自己也能持有.
* 不再需要自己持有的对象时释放.
* 非自己持有的对象无法释放.

按照这个思路, 完全不必考虑引用计数. OC 方法表如下:

<table border="1">
<tr>
<th>对象操作</th>
<th>Objective-C 方法</th>
</tr>
<tr>
<td>生成并持有对象</td>
<td>alloc/ new/ copy/ mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain 方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release 方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc 方法</td>
</tr>
</table>

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">指针:</h2>

<p>指针是一种数据类型, 它存储一个变量的内存地址. "因为对象只能通过指针访问, 所以人们常用指向对象的指针来称呼对象. <strong>注意: 指针和它指向的对象是不同的.</strong>"</p>

<h2 id="">引用计数:</h2>

<p>"Cocoa 采用了一种叫做引用计数 (reference counting) 的技术, 有时也叫做保留计数 (retain counting). 每一个对象都有一个与之相关的整数, 被称作它的引用计数器或保留计数器."</p>

<p>"Objective-C 语言使用引用计数来管理内存, 也就是说每个对象有一个可以递增递减的计数器. 如果想让某个对象继续存活, 就将递增其引用计数器, 用完了之后就递减其计数. 计数器为0就表示没人关注此对象了, 于是就可以把它销毁."</p>

<p>在我看来, 引用计数器的值就等同于指向对象的指针的数量.</p>

<h2 id="">内存管理的思考方式:</h2>

<p>手动内存管理 (manual reference counting) 很容易受到引用计数器的值得影响, 仅仅是将它递增递减, 实际上合理的思考方式应该是:</p>

<ul>
<li>自己生成的对象, 自己持有.</li>
<li>非自己生成的对象, 自己也能持有.</li>
<li>不再需要自己持有的对象时释放.</li>
<li>非自己持有的对象无法释放.</li>
</ul>

<p>按照这个思路, 完全不必考虑引用计数. OC 方法表如下:</p>

<table border="1">
<tbody><tr>
<th>对象操作</th>
<th>Objective-C 方法</th>
</tr>
<tr>
<td>生成并持有对象</td>
<td>alloc/ new/ copy/ mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain 方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release 方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc 方法</td>
</tr>
</tbody></table>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "oc_memory_2.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
