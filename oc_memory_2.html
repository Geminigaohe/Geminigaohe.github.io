<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
## 指针:

指针是一种数据类型, 它存储一个变量的内存地址. "因为对象只能通过指针访问, 所以人们常用指向对象的指针来称呼对象. **注意: 指针和它指向的对象是不同的.**"

## 引用计数:

"Cocoa 采用了一种叫做引用计数 (reference counting) 的技术, 有时也叫做保留计数 (retain counting). 每一个对象都有一个与之相关的整数, 被称作它的引用计数器或保留计数器."

"Objective-C 语言使用引用计数来管理内存, 也就是说每个对象有一个可以递增递减的计数器. 如果想让某个对象继续存活, 就将递增其引用计数器, 用完了之后就递减其计数. 计数器为0就表示没人关注此对象了, 于是就可以把它销毁."

在我看来, 引用计数器的值就等同于指向对象的指针的数量.

## 内存管理的思考方式:

手动内存管理 (manual reference counting) 很容易受到引用计数器的影响, 仅仅是将它递增递减, 实际上合理的思考方式应该是:

* 自己生成的对象, 自己持有.
* 非自己生成的对象, 自己也能持有.
* 不再需要自己持有的对象时释放.
* 非自己持有的对象无法释放.

按照这个思路, 完全不必考虑引用计数. OC 方法表如下:

<table border="1">
<tr>
<th>对象操作</th>
<th>Objective-C 方法</th>
</tr>
<tr>
<td>生成并持有对象</td>
<td>alloc/ new/ copy/ mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain 方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release 方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc 方法</td>
</tr>
<tr>
<td>引用计数器值</td>
<td>retaincount 方法</td>
</tr>
</table>


##  自己生成并持有对象:
~~~~{c}
id obj = [[NSObect alloc] init]; // alloc 方法

id obj = [NSObject new]; // new 方法

id obj = [NSObject copy]; // copy 方法

id obj = [NSObject mutableCopy]; //mutableCopy 方法
~~~~

只有以  `alloc`/ `new`/ `copy`/ `mutableCopy` 开头并且以驼峰写法的方法才能自己生成并持有对象, 如:

* initWithSomething
* copyFormThere

其他命名方式就无法自己生成并持有对象, 如:

* initsomething
* mutablecopy
## 非自己生成的对象, 自己也能持有:
~~~~{c}
NSArray *array = [NSArray array]; 

// 取得对象的存在, 但是自己不持有对象
~~~~

~~~~{c}

NSArray *array_2 = [NSArray array]; 

// 取得对象的存在, 但是自己不持有对象

[array retain]; 

// 自己持有对象
~~~~


## 不在需要自己持有的对象时释放:

~~~~{c}
// 自己生成并持有对象

id obj = [NSObject new];

//自己持有对象

[obj release]; 

// 释放对象

//===================================

NSArray *array_2 = [NSArray array]; 

// 取得对象的存在, 但是自己不持有对象

[array retain]; 

// 自己持有对象

[array release];

// 释放对象
~~~~

如果要用某个方法生成对象, 并将其返还给该方法的调用方, 那么它的源码又是怎样的呢?

~~~~{c}
- (id) allocObject {
	id obj = [[NSObject alloc] init];
	//自己持有对象
	return obj;
}
~~~~

那么, 调用 `[NSArray array]`方法取得对象的存在, 但自己不持有对象, 又是如何实现的呢? 根据前面的命名规定, 不能使用以 `alloc`/ `new`/ `copy`/ `mutableCopy` 开头的方法名, 因此要使用 object 这个方法名:

~~~~{c}
- (id) object {
	id obj = [[NSObject alloc] init];
	//自己持有对象
	[obj autorelease];
	// 取得对象的存在, 但自己不持有对象
}
~~~~

## 无法释放非自己持有的对象:

~~~~{c}
id obj = [[NSObject alloc] init];

// 自己持有对象

[obj release];

// 对象已经释放

[obj release];

/**
 释放之后再次释放已经非自己持有的对象.
 访问已经废弃的对象时程序崩溃.
**/
~~~~

或者,在 "取得了对象的存在, 但自己不持有对象" 时释放对象

~~~~{c}
id obj = [obj_1 object];

// 取得对象的存在, 但是自己不持有对象

[obj release];

/**
 释放了非自己持有的对象, 程序崩溃
**/
~~~~

## 总结:

观察对象引用计数的值不是内存管理的好的思路, Cocoa 有完好的解决对象内存管理的方案.

<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">指针:</h2>

<p>指针是一种数据类型, 它存储一个变量的内存地址. "因为对象只能通过指针访问, 所以人们常用指向对象的指针来称呼对象. <strong>注意: 指针和它指向的对象是不同的.</strong>"</p>

<h2 id="">引用计数:</h2>

<p>"Cocoa 采用了一种叫做引用计数 (reference counting) 的技术, 有时也叫做保留计数 (retain counting). 每一个对象都有一个与之相关的整数, 被称作它的引用计数器或保留计数器."</p>

<p>"Objective-C 语言使用引用计数来管理内存, 也就是说每个对象有一个可以递增递减的计数器. 如果想让某个对象继续存活, 就将递增其引用计数器, 用完了之后就递减其计数. 计数器为0就表示没人关注此对象了, 于是就可以把它销毁."</p>

<p>在我看来, 引用计数器的值就等同于指向对象的指针的数量.</p>

<h2 id="">内存管理的思考方式:</h2>

<p>手动内存管理 (manual reference counting) 很容易受到引用计数器的影响, 仅仅是将它递增递减, 实际上合理的思考方式应该是:</p>

<ul>
<li>自己生成的对象, 自己持有.</li>
<li>非自己生成的对象, 自己也能持有.</li>
<li>不再需要自己持有的对象时释放.</li>
<li>非自己持有的对象无法释放.</li>
</ul>

<p>按照这个思路, 完全不必考虑引用计数. OC 方法表如下:</p>

<table border="1">
<tbody><tr>
<th>对象操作</th>
<th>Objective-C 方法</th>
</tr>
<tr>
<td>生成并持有对象</td>
<td>alloc/ new/ copy/ mutableCopy 等方法</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain 方法</td>
</tr>
<tr>
<td>释放对象</td>
<td>release 方法</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc 方法</td>
</tr>
<tr>
<td>引用计数器值</td>
<td>retaincount 方法</td>
</tr>
</tbody></table>

<h2 id="">自己生成并持有对象:</h2>

<pre class=" language-c"><code class=" language-c">id obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObect alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // alloc 方法
</span>
id obj <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject new<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // new 方法
</span>
id obj <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject copy<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // copy 方法
</span>
id obj <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject mutableCopy<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> //mutableCopy 方法
</span></code></pre>

<p>只有以  <code>alloc</code>/ <code>new</code>/ <code>copy</code>/ <code>mutableCopy</code> 开头并且以驼峰写法的方法才能自己生成并持有对象, 如:</p>

<ul>
<li>initWithSomething</li>
<li>copyFormThere</li>
</ul>

<p>其他命名方式就无法自己生成并持有对象, 如:</p>

<ul>
<li>initsomething</li>
<li>mutablecopy</li>
</ul>

<h2 id="">非自己生成的对象, 自己也能持有:</h2>

<pre class=" language-c"><code class=" language-c">NSArray <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token punctuation">[</span>NSArray array<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 取得对象的存在, 但是自己不持有对象
</span></code></pre>

<pre class=" language-c"><code class=" language-c">
NSArray <span class="token operator">*</span>array_2 <span class="token operator">=</span> <span class="token punctuation">[</span>NSArray array<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 取得对象的存在, 但是自己不持有对象
</span>
<span class="token punctuation">[</span>array retain<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 自己持有对象
</span></code></pre>

<h2 id="">不在需要自己持有的对象时释放:</h2>

<pre class=" language-c"><code class=" language-c"><span class="token comment" spellcheck="true">// 自己生成并持有对象
</span>
id obj <span class="token operator">=</span> <span class="token punctuation">[</span>NSObject new<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
//自己持有对象
</span>
<span class="token punctuation">[</span>obj release<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 释放对象
</span><span class="token comment" spellcheck="true">
//===================================
</span>
NSArray <span class="token operator">*</span>array_2 <span class="token operator">=</span> <span class="token punctuation">[</span>NSArray array<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 取得对象的存在, 但是自己不持有对象
</span>
<span class="token punctuation">[</span>array retain<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">
// 自己持有对象
</span>
<span class="token punctuation">[</span>array release<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 释放对象
</span></code></pre>

<p>如果要用某个方法生成对象, 并将其返还给该方法的调用方, 那么它的源码又是怎样的呢?</p>

<pre class=" language-c"><code class=" language-c"><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> allocObject <span class="token punctuation">{</span>
    id obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true"> //自己持有对象
</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

<p>那么, 调用 <code>[NSArray array]</code>方法取得对象的存在, 但自己不持有对象, 又是如何实现的呢? 根据前面的命名规定, 不能使用以 <code>alloc</code>/ <code>new</code>/ <code>copy</code>/ <code>mutableCopy</code> 开头的方法名, 因此要使用 object 这个方法名:</p>

<pre class=" language-c"><code class=" language-c"><span class="token operator">-</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> object <span class="token punctuation">{</span>
    id obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true"> //自己持有对象
</span>    <span class="token punctuation">[</span>obj autorelease<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true"> // 取得对象的存在, 但自己不持有对象
</span><span class="token punctuation">}</span>
</code></pre>

<h2 id="">无法释放非自己持有的对象:</h2>

<pre class=" language-c"><code class=" language-c">id obj <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>NSObject alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 自己持有对象
</span>
<span class="token punctuation">[</span>obj release<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 对象已经释放
</span>
<span class="token punctuation">[</span>obj release<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 释放之后再次释放已经非自己持有的对象.
 访问已经废弃的对象时程序崩溃.
**/</span>
</code></pre>

<p>或者,在 "取得了对象的存在, 但自己不持有对象" 时释放对象</p>

<pre class=" language-c"><code class=" language-c">id obj <span class="token operator">=</span> <span class="token punctuation">[</span>obj_1 object<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 取得对象的存在, 但是自己不持有对象
</span>
<span class="token punctuation">[</span>obj release<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 释放了非自己持有的对象, 程序崩溃
**/</span>
</code></pre>

<h2 id="">总结:</h2>

<p>观察对象引用计数的值不是内存管理的好的思路, Cocoa 有完好的解决对象内存管理的方案.</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "oc_memory_2.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
