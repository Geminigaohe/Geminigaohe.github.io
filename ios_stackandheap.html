<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>iOS 关于堆和栈 (转载)</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
>iOS 操作系统中应用程序使用的计算机内存不是统一分配空间, 运行代码使用的空间在三个不同的内存区域, 分成三个段: "text segment", "stack segment ", "heap segment ".

<center>![](https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/image/%E5%A0%86%E5%92%8C%E6%A0%88_2.jpg)</center>

段 "text segment" 是应用程序运行时应用程序代码存在的内存段. 每一个指令, 每一个单个函数, 过程, 方法和执行代码都存在这个内存段中直到应用程序退出. 一般情况下, 你不会真的不得不知道这个段的任何事情.

当应用开始以后, 函数 main() 被调用, 一些空间分配在 "stack" 中. 这是为应用分配的另一个段的内存空间, 这是为了函数变量存储需要而分配的内存. 每一次在应用中调用一个函数, "stack" 的一部分会被分配在 "stack" 中, 称之为 "frame". 新函数的本地变量分配在这里.

正如名称所示, "stack" 是后进先出 (LIFO) 结构. 当函数调用其他的函数时, "stack frame" 会被创建; 当其他函数退出后, 这个 "frame" 会自动被破坏.

 "heap" 段也称为 "data" 段, 提供一个保存中介贯穿函数的执行过程, 全局和静态变量保存在 "heap"中, 直到应用退出.

为了访问你创建在 "heap" 中的数据, 你最少要求有一个保存在 "stack" 中的指针, 因为你的 CPU 通过 "stack" 中的指针访问 "heap" 中的数据.

你可以认为 "stack" 中的一个指针仅仅是一个整型变量, 保存了 "heap" 中特定内存地址的数据. 实际上, 它有一点点复杂, 但这是它的基本结构.

**简而言之, 操作系统使用 "stack" 段中的指针值访问 "heap" 段中的对象. 如果 "stack" 对象的指针没有了, 则 "heap" 中的对象就不能访问. 这也是内存泄露的原因.**

在 iOS 操作系统的 "stack" 段和 "heap" 段中，你都可以创建数据对象.

"stack" 对象的优点主要有两点, 一是创建速度快, 二是管理简单, 它有严格的生命周期. stack 对象的缺点是它不灵活. 创建时长度是多大就一直是多大, 创建时是哪个函数创建的, 它的 "owner" 就一直是它. 不像 "heap" 对象那样有多个 "owner", 其实多个 "owner" 等同于引用计数. **只有 "heap" 对象才是采用引用计数方法管理它.**

* "stack" 对象的创建:

只要栈的剩余空间大于stack 对象申请创建的空间, 操作系统就会为程序提供这段内存空间, 否则将报异常提示栈溢出.

* "heap" 对象的创建:

操作系统对于内存 "heap" 段是采用链表进行管理的. 操作系统有一个记录空闲内存地址的链表, 当收到程序的申请时, 会遍历链表, 寻找第一个空间大于所申请的 "heap" 节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序.

例如: 

NSString 的对象就是 "stack" 中的对象，NSMutableString 的对象就是 "heap" 中的对象. 前者创建时分配的内存长度固定且不可修改, 后者是分配内存长度是可变的, 可有多个owner, 适用于计数管理内存管理模式.

两类对象的创建方法也不同, 前者直接创建 `NSString * str1=@"welcome";` 而后者需要先分配再初始化` NSMutableString * mstr1=[[NSMutableString alloc] initWithString:@"welcome"]; `

 
* 再补充一点, 这里说的是操作系统的堆和栈: 

在我们学习 "数据结构" 时, 接触到的堆和栈的概念和这个操作系统中的堆和栈不是一回事的.

操作系统的堆和栈是指对内存进行操作和管理的一些方式.

"数据结构" 的堆实际上指的就是 (满足堆性质的) 优先 Queue 的一种数据结构, 第1个元素有最高的优先权, 栈实际上就是满足先进后出的性质的数据或数据结构.

[原文链接](http://mikixiyou.iteye.com/blog/1595230)
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<blockquote>
  <p>iOS 操作系统中应用程序使用的计算机内存不是统一分配空间, 运行代码使用的空间在三个不同的内存区域, 分成三个段: "text segment", "stack segment ", "heap segment ".</p>
</blockquote>

<p></p><center><img src="https://raw.githubusercontent.com/Geminigaohe/Geminigaohe.github.io/master/image/%E5%A0%86%E5%92%8C%E6%A0%88_2.jpg" alt="" title=""></center><p></p>

<p>段 "text segment" 是应用程序运行时应用程序代码存在的内存段. 每一个指令, 每一个单个函数, 过程, 方法和执行代码都存在这个内存段中直到应用程序退出. 一般情况下, 你不会真的不得不知道这个段的任何事情.</p>

<p>当应用开始以后, 函数 main() 被调用, 一些空间分配在 "stack" 中. 这是为应用分配的另一个段的内存空间, 这是为了函数变量存储需要而分配的内存. 每一次在应用中调用一个函数, "stack" 的一部分会被分配在 "stack" 中, 称之为 "frame". 新函数的本地变量分配在这里.</p>

<p>正如名称所示, "stack" 是后进先出 (LIFO) 结构. 当函数调用其他的函数时, "stack frame" 会被创建; 当其他函数退出后, 这个 "frame" 会自动被破坏.</p>

<p>"heap" 段也称为 "data" 段, 提供一个保存中介贯穿函数的执行过程, 全局和静态变量保存在 "heap"中, 直到应用退出.</p>

<p>为了访问你创建在 "heap" 中的数据, 你最少要求有一个保存在 "stack" 中的指针, 因为你的 CPU 通过 "stack" 中的指针访问 "heap" 中的数据.</p>

<p>你可以认为 "stack" 中的一个指针仅仅是一个整型变量, 保存了 "heap" 中特定内存地址的数据. 实际上, 它有一点点复杂, 但这是它的基本结构.</p>

<p><strong>简而言之, 操作系统使用 "stack" 段中的指针值访问 "heap" 段中的对象. 如果 "stack" 对象的指针没有了, 则 "heap" 中的对象就不能访问. 这也是内存泄露的原因.</strong></p>

<p>在 iOS 操作系统的 "stack" 段和 "heap" 段中，你都可以创建数据对象.</p>

<p>"stack" 对象的优点主要有两点, 一是创建速度快, 二是管理简单, 它有严格的生命周期. stack 对象的缺点是它不灵活. 创建时长度是多大就一直是多大, 创建时是哪个函数创建的, 它的 "owner" 就一直是它. 不像 "heap" 对象那样有多个 "owner", 其实多个 "owner" 等同于引用计数. <strong>只有 "heap" 对象才是采用引用计数方法管理它.</strong></p>

<ul>
<li>"stack" 对象的创建:</li>
</ul>

<p>只要栈的剩余空间大于stack 对象申请创建的空间, 操作系统就会为程序提供这段内存空间, 否则将报异常提示栈溢出.</p>

<ul>
<li>"heap" 对象的创建:</li>
</ul>

<p>操作系统对于内存 "heap" 段是采用链表进行管理的. 操作系统有一个记录空闲内存地址的链表, 当收到程序的申请时, 会遍历链表, 寻找第一个空间大于所申请的 "heap" 节点, 然后将该节点从空闲节点链表中删除, 并将该节点的空间分配给程序.</p>

<p>例如: </p>

<p>NSString 的对象就是 "stack" 中的对象，NSMutableString 的对象就是 "heap" 中的对象. 前者创建时分配的内存长度固定且不可修改, 后者是分配内存长度是可变的, 可有多个owner, 适用于计数管理内存管理模式.</p>

<p>两类对象的创建方法也不同, 前者直接创建 <code>NSString * str1=@"welcome";</code> 而后者需要先分配再初始化<code>NSMutableString * mstr1=[[NSMutableString alloc] initWithString:@"welcome"];</code></p>

<ul>
<li>再补充一点, 这里说的是操作系统的堆和栈: </li>
</ul>

<p>在我们学习 "数据结构" 时, 接触到的堆和栈的概念和这个操作系统中的堆和栈不是一回事的.</p>

<p>操作系统的堆和栈是指对内存进行操作和管理的一些方式.</p>

<p>"数据结构" 的堆实际上指的就是 (满足堆性质的) 优先 Queue 的一种数据结构, 第1个元素有最高的优先权, 栈实际上就是满足先进后出的性质的数据或数据结构.</p>

<p><a href="http://mikixiyou.iteye.com/blog/1595230">原文链接</a></p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2016 by GaoHe, Designed by GaoHe</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "ios_stackandheap.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
